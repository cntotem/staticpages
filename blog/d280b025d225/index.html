<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="keywords" content="九天图腾,博客"><meta name="description" content="九天图腾个人博客"><meta name="author" content="九天图腾"><title>深入浅出负载均衡 | 九天图腾</title><link rel="stylesheet" href="../css/style.css"><link rel="shortcut icon" href="../images/logo.svg"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/css/font-awesome.min.css"><script id="hexo-configurations">let KEEP=window.KEEP||{};KEEP.hexo_config={hostname:"blog.yusei.zone",root:"/",language:"zh-CN",path:"search.xml"},KEEP.theme_config={toc:{enable:!0,number:!1,expand_all:!1,init_open:!1},style:{primary_color:"#0066CC",avatar:"/images/avatar.jpeg",favicon:"/images/logo.svg",article_img_align:"center",left_side_width:"260px",content_max_width:"920px",hover:{shadow:!0,scale:!0},first_screen:{enable:!0,background_img:"/images/bg.svg",description:"所谓卓越，并非指行为，而是习惯。"},scroll:{progress_bar:{enable:!0},percent:{enable:!0}}},local_search:{enable:!0,preload:!0},code_copy:{enable:!0,style:"default"},pjax:{enable:!1},lazyload:{enable:!1},version:"3.4.3"},KEEP.language_ago={second:"%s 秒前",minute:"%s 分钟前",hour:"%s 小时前",day:"%s 天前",week:"%s 周前",month:"%s 月前",year:"%s 年前"}</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="atom.xml" title="九天图腾" type="application/atom+xml">
</head><body><div class="progress-bar-container"><span class="scroll-progress-bar"></span></div><main class="page-container"><div class="page-main-content"><div class="page-main-content-top"><header class="header-wrapper"><div class="header-content"><div class="left"><a class="logo-title" href="/">九天图腾</a></div><div class="right"><div class="pc"><ul class="menu-list"><li class="menu-item"><a href="../index.html">首页</a></li><li class="menu-item"><a href="../archives">归档</a></li><li class="menu-item"><a href="../links">友链</a></li><li class="menu-item"><a href="../about">关于</a></li><li class="menu-item search search-popup-trigger"><i class="fas fa-search"></i></li></ul></div><div class="mobile"><div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div><div class="icon-item menu-bar"><div class="menu-bar-middle"></div></div></div></div></div><div class="header-drawer"><ul class="drawer-menu-list"><li class="drawer-menu-item flex-center"><a href="../index.html">首页</a></li><li class="drawer-menu-item flex-center"><a href="../archives">归档</a></li><li class="drawer-menu-item flex-center"><a href="../links">友链</a></li><li class="drawer-menu-item flex-center"><a href="../about">关于</a></li></ul></div><div class="window-mask"></div></header></div><div class="page-main-content-middle"><div class="main-content"><div class="fade-in-down-animation"><div class="article-content-container"><div class="article-title"><span class="title-hover-animation">深入浅出负载均衡</span></div><div class="article-header"><div class="avatar"><img src="../images/avatar.jpeg"></div><div class="info"><div class="author"><span class="name">九天图腾</span> <span class="author-label">化境期</span></div><div class="meta-info"><div class="article-meta-info"><span class="article-date article-meta-item"><i class="fas fa-edit"></i>&nbsp;2018-07-05 15:50:00 </span><span class="article-categories article-meta-item"><i class="fas fa-folder"></i>&nbsp;<ul><li><a href="../categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a>&nbsp;</li></ul></span><span class="article-tags article-meta-item"><i class="fas fa-tags"></i>&nbsp;<ul><li><a href="../tags/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a>&nbsp;</li><li>| <a href="../tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/">负载均衡</a>&nbsp;</li></ul></span><span class="article-wordcount article-meta-item"><i class="fas fa-file-word"></i>&nbsp;<span>7.9k 字</span> </span><span class="article-min2read article-meta-item"><i class="fas fa-clock"></i>&nbsp;<span>31 分钟</span> </span><span class="article-pv article-meta-item"><i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span></span></div></div></div></div><div class="article-content markdown-body"><h1 id="深入浅出负载均衡"><a href="#深入浅出负载均衡" class="headerlink" title="深入浅出负载均衡"></a>深入浅出负载均衡</h1><blockquote><p>📦 本文已归档到：「<a class="link" target="_blank" rel="noopener" href="https://github.com/dunwu/blog">blog<i class="fas fa-external-link-alt"></i></a>」</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/cntotemdb/ih1@master/202106/pEk9gY.png" alt="img"></p><ul><li><a href="#1-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%80%E4%BB%8B">1. 负载均衡简介</a><ul><li><a href="#11-%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E9%9D%A2%E4%B8%B4%E7%9A%84%E6%8C%91%E6%88%98">1.1. 大型网站面临的挑战</a></li><li><a href="#12-%E4%BB%80%E4%B9%88%E6%98%AF%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1">1.2. 什么是负载均衡</a></li></ul></li><li><a href="#2-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%9A%84%E5%88%86%E7%B1%BB">2. 负载均衡的分类</a><ul><li><a href="#21-%E8%BD%BD%E4%BD%93%E7%BB%B4%E5%BA%A6%E5%88%86%E7%B1%BB">2.1. 载体维度分类</a></li><li><a href="#22-%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%88%86%E7%B1%BB">2.2. 网络通信分类</a></li></ul></li><li><a href="#3-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95">3. 负载均衡算法</a><ul><li><a href="#31-%E9%9A%8F%E6%9C%BA">3.1. 随机</a></li><li><a href="#32-%E8%BD%AE%E8%AF%A2">3.2. 轮询</a></li><li><a href="#33-%E6%9C%80%E5%B0%8F%E6%B4%BB%E8%B7%83%E6%95%B0">3.3. 最小活跃数</a></li><li><a href="#34-%E6%BA%90%E5%9C%B0%E5%9D%80%E5%93%88%E5%B8%8C">3.4. 源地址哈希</a></li><li><a href="#35-%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C">3.5. 一致性哈希</a></li></ul></li><li><a href="#4-%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">4. 参考资料</a></li></ul><h2 id="1-负载均衡简介"><a href="#1-负载均衡简介" class="headerlink" title="1. 负载均衡简介"></a>1. 负载均衡简介</h2><h3 id="1-1-大型网站面临的挑战"><a href="#1-1-大型网站面临的挑战" class="headerlink" title="1.1. 大型网站面临的挑战"></a>1.1. 大型网站面临的挑战</h3><p>大型网站都要面对庞大的用户量，高并发，海量数据等挑战。</p><p>为了提升系统整体的性能，可以采用垂直扩展和水平扩展两种方式。</p><ul><li><strong>垂直扩展</strong>：在网站发展早期，可以从单机的角度通过<strong>增加硬件处理能力</strong>，比如 CPU 处理能力，内存容量，磁盘等方面，实现服务器处理能力的提升。但是，单机是有性能瓶颈的，一旦触及瓶颈，再想提升，付出的成本和代价会极高。这显然不能满足大型分布式系统（网站）所有应对的大流量，高并发，海量数据等挑战。</li><li><strong>水平扩展</strong>：通过集群来分担大型网站的流量。集群中的应用服务器（节点）通常被设计成无状态，用户可以请求任何一个节点，这些节点共同分担访问压力。水平扩展有两个要点：<ul><li><strong>应用集群</strong>：将同一应用部署到多台机器上，组成处理集群，接收负载均衡设备分发的请求，进行处理，并返回相应数据。</li><li><strong>负载均衡</strong>：将用户访问请求，通过某种算法，分发到集群中的节点。</li></ul></li></ul><h3 id="1-2-什么是负载均衡"><a href="#1-2-什么是负载均衡" class="headerlink" title="1.2. 什么是负载均衡"></a>1.2. 什么是负载均衡</h3><p>负载均衡（Load Balance，简称 LB）是高并发、高可用系统必不可少的关键组件，目标是 <strong>尽力将网络流量平均分发到多个服务器上，以提高系统整体的响应速度和可用性</strong>。</p><p>负载均衡的主要作用如下：</p><ul><li><strong>高并发</strong>：负载均衡通过算法调整负载，尽力均匀的分配应用集群中各节点的工作量，以此提高应用集群的并发处理能力（吞吐量）。</li><li><strong>伸缩性</strong>：添加或减少服务器数量，然后由负载均衡进行分发控制。这使得应用集群具备伸缩性。</li><li><strong>高可用</strong>：负载均衡器可以监控候选服务器，当服务器不可用时，自动跳过，将请求分发给可用的服务器。这使得应用集群具备高可用的特性。</li><li><strong>安全防护</strong>：有些负载均衡软件或硬件提供了安全性功能，如：黑白名单处理、防火墙，防 DDos 攻击等。</li></ul><h2 id="2-负载均衡的分类"><a href="#2-负载均衡的分类" class="headerlink" title="2. 负载均衡的分类"></a>2. 负载均衡的分类</h2><p>支持负载均衡的技术很多，我们可以通过不同维度去进行分类。</p><h3 id="2-1-载体维度分类"><a href="#2-1-载体维度分类" class="headerlink" title="2.1. 载体维度分类"></a>2.1. 载体维度分类</h3><p>从支持负载均衡的载体来看，可以将负载均衡分为两类：</p><ul><li>硬件负载均衡</li><li>软件负载均衡</li></ul><h4 id="硬件负载均衡"><a href="#硬件负载均衡" class="headerlink" title="硬件负载均衡"></a>硬件负载均衡</h4><p>硬件负载均衡，一般是在定制处理器上运行的独立负载均衡服务器，<strong>价格昂贵，土豪专属</strong>。</p><p>硬件负载均衡的 <strong>主流产品</strong> 有：<a class="link" target="_blank" rel="noopener" href="https://f5.com/zh">F5<i class="fas fa-external-link-alt"></i></a> 和 <a class="link" target="_blank" rel="noopener" href="https://www.a10networks.com.cn/">A10<i class="fas fa-external-link-alt"></i></a>。</p><p>硬件负载均衡的 <strong>优点</strong>：</p><ul><li><strong>功能强大</strong>：支持全局负载均衡并提供较全面的、复杂的负载均衡算法。</li><li><strong>性能强悍</strong>：硬件负载均衡由于是在专用处理器上运行，因此吞吐量大，可支持单机百万以上的并发。</li><li><strong>安全性高</strong>：往往具备防火墙，防 DDos 攻击等安全功能。</li></ul><p>硬件负载均衡的 <strong>缺点</strong>：</p><ul><li><strong>成本昂贵</strong>：购买和维护硬件负载均衡的成本都很高。</li><li><strong>扩展性差</strong>：当访问量突增时，超过限度不能动态扩容。</li></ul><h4 id="软件负载均衡"><a href="#软件负载均衡" class="headerlink" title="软件负载均衡"></a>软件负载均衡</h4><p>软件负载均衡，<strong>应用最广泛</strong>，无论大公司还是小公司都会使用。</p><p>软件负载均衡从软件层面实现负载均衡，一般可以在任何标准物理设备上运行。</p><p>软件负载均衡的 <strong>主流产品</strong> 有：<a class="link" target="_blank" rel="noopener" href="https://www.nginx.com/">Nginx<i class="fas fa-external-link-alt"></i></a>、<a class="link" target="_blank" rel="noopener" href="http://www.haproxy.org/">HAProxy<i class="fas fa-external-link-alt"></i></a>、<a class="link" target="_blank" rel="noopener" href="https://github.com/alibaba/LVS">LVS<i class="fas fa-external-link-alt"></i></a>。</p><ul><li><a class="link" target="_blank" rel="noopener" href="https://github.com/alibaba/LVS">LVS<i class="fas fa-external-link-alt"></i></a> 可以作为四层负载均衡器。其负载均衡的性能要优于 Nginx。</li><li><a class="link" target="_blank" rel="noopener" href="http://www.haproxy.org/">HAProxy<i class="fas fa-external-link-alt"></i></a> 可以作为 HTTP 和 TCP 负载均衡器。</li><li><a class="link" target="_blank" rel="noopener" href="https://www.nginx.com/">Nginx<i class="fas fa-external-link-alt"></i></a>、<a class="link" target="_blank" rel="noopener" href="http://www.haproxy.org/">HAProxy<i class="fas fa-external-link-alt"></i></a> 可以作为四层或七层负载均衡器。</li></ul><p>软件负载均衡的 <strong>优点</strong>：</p><ul><li><strong>扩展性好</strong>：适应动态变化，可以通过添加软件负载均衡实例，动态扩展到超出初始容量的能力。</li><li><strong>成本低廉</strong>：软件负载均衡可以在任何标准物理设备上运行，降低了购买和运维的成本。</li></ul><p>软件负载均衡的 <strong>缺点</strong>：</p><ul><li><strong>性能略差</strong>：相比于硬件负载均衡，软件负载均衡的性能要略低一些。</li></ul><h3 id="2-2-网络通信分类"><a href="#2-2-网络通信分类" class="headerlink" title="2.2. 网络通信分类"></a>2.2. 网络通信分类</h3><p>软件负载均衡从通信层面来看，又可以分为四层和七层负载均衡。</p><ul><li>七层负载均衡：就是可以根据访问用户的 HTTP 请求头、URL 信息将请求转发到特定的主机。<ul><li>DNS 重定向</li><li>HTTP 重定向</li><li>反向代理</li></ul></li><li>四层负载均衡：基于 IP 地址和端口进行请求的转发。<ul><li>修改 IP 地址</li><li>修改 MAC 地址</li></ul></li></ul><h4 id="DNS-负载均衡"><a href="#DNS-负载均衡" class="headerlink" title="DNS 负载均衡"></a>DNS 负载均衡</h4><p>DNS 负载均衡一般用于互联网公司，复杂的业务系统不适合使用。大型网站一般使用 DNS 负载均衡作为 <strong>第一级负载均衡手段</strong>，然后在内部使用其它方式做第二级负载均衡。DNS 负载均衡属于七层负载均衡。</p><p>DNS 即 <strong>域名解析服务</strong>，是 OSI 第七层网络协议。DNS 被设计为一个树形结构的分布式应用，自上而下依次为：根域名服务器，一级域名服务器，二级域名服务器，… ，本地域名服务器。显然，如果所有数据都存储在根域名服务器，那么 DNS 查询的负载和开销会非常庞大。</p><p>因此，DNS 查询相对于 DNS 层级结构，是一个逆向的递归流程，DNS 客户端依次请求本地 DNS 服务器，上一级 DNS 服务器，上上一级 DNS 服务器，… ，根 DNS 服务器（又叫权威 DNS 服务器），一旦命中，立即返回。为了减少查询次数，每一级 DNS 服务器都会设置 DNS 查询缓存。</p><p>DNS 负载均衡的工作原理就是：<strong>基于 DNS 查询缓存，按照负载情况返回不同服务器的 IP 地址</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/cntotemdb/ih1@master/202106/ZZFzQY.png" alt="img"></p><p>DNS 重定向的 <strong>优点</strong>：</p><ul><li><strong>使用简单</strong>：负载均衡工作，交给 DNS 服务器处理，省掉了负载均衡服务器维护的麻烦</li><li><strong>提高性能</strong>：可以支持基于地址的域名解析，解析成距离用户最近的服务器地址（类似 CDN 的原理），可以加快访问速度，改善性能；</li></ul><p>DNS 重定向的 <strong>缺点</strong>：</p><ul><li><strong>可用性差</strong>：DNS 解析是多级解析，新增/修改 DNS 后，解析时间较长；解析过程中，用户访问网站将失败；</li><li><strong>扩展性低</strong>：DNS 负载均衡的控制权在域名商那里，无法对其做更多的改善和扩展；</li><li><strong>维护性差</strong>：也不能反映服务器的当前运行状态；支持的算法少；不能区分服务器的差异（不能根据系统与服务的状态来判断负载）</li></ul><h4 id="HTTP-负载均衡"><a href="#HTTP-负载均衡" class="headerlink" title="HTTP 负载均衡"></a>HTTP 负载均衡</h4><p><strong>HTTP 负载均衡是基于 HTTP 重定向实现的</strong>。HTTP 负载均衡属于七层负载均衡。</p><p>HTTP 重定向原理是：<strong>根据用户的 HTTP 请求计算出一个真实的服务器地址，将该服务器地址写入 HTTP 重定向响应中，返回给浏览器，由浏览器重新进行访问</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/cntotemdb/ih1@master/202106/xQWgam.png" alt="img"></p><p>HTTP 重定向的 <strong>优点</strong>：<strong>方案简单</strong>。</p><p>HTTP 重定向的 <strong>缺点</strong>：</p><ul><li><strong>性能较差</strong>：每次访问需要两次请求服务器，增加了访问的延迟。</li><li><strong>降低搜索排名</strong>：使用重定向后，搜索引擎会视为 SEO 作弊。</li><li>如果负载均衡器宕机，就无法访问该站点。</li></ul><p>由于其缺点比较明显，所以这种负载均衡策略实际应用较少。</p><h4 id="反向代理负载均衡"><a href="#反向代理负载均衡" class="headerlink" title="反向代理负载均衡"></a>反向代理负载均衡</h4><p>反向代理（Reverse Proxy）方式是指以 <strong>代理服务器</strong> 来接受网络请求，然后 <strong>将请求转发给内网中的服务器</strong>，并将从内网中的服务器上得到的结果返回给网络请求的客户端。反向代理负载均衡属于七层负载均衡。</p><p>反向代理服务的主流产品：<strong>Nginx</strong>、<strong>Apache</strong>。</p><p>正向代理与反向代理有什么区别？</p><ul><li>正向代理：发生在 <strong>客户端</strong>，是由用户主动发起的。翻墙软件就是典型的正向代理，客户端通过主动访问代理服务器，让代理服务器获得需要的外网数据，然后转发回客户端。</li><li>反向代理：发生在 <strong>服务端</strong>，用户不知道代理的存在。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/cntotemdb/ih1@master/202106/Ap3l5x.png" alt="img"></p><p>反向代理是如何实现负载均衡的呢？以 Nginx 为例，如下所示：</p><p><img src="https://cdn.jsdelivr.net/gh/cntotemdb/ih1@master/202106/p7zPee.png" alt="img"></p><p>首先，在代理服务器上设定好负载均衡规则。然后，当收到客户端请求，反向代理服务器拦截指定的域名或 IP 请求，根据负载均衡算法，将请求分发到候选服务器上。其次，如果某台候选服务器宕机，反向代理服务器会有容错处理，比如分发请求失败 3 次以上，将请求分发到其他候选服务器上。</p><p>反向代理的 <strong>优点</strong>：</p><ul><li><strong>多种负载均衡算法</strong>：支持多种负载均衡算法，以应对不同的场景需求。</li><li><strong>可以监控服务器</strong>：基于 HTTP 协议，可以监控转发服务器的状态，如：系统负载、响应时间、是否可用、连接数、流量等，从而根据这些数据调整负载均衡的策略。</li></ul><p>反向代理的 <strong>缺点</strong>：</p><ul><li><p><strong>额外的转发开销</strong>：反向代理的转发操作本身是有性能开销的，可能会包括创建连接，等待连接响应，分析响应结果等操作。</p></li><li><p><strong>增加系统复杂度</strong>：反向代理常用于做分布式应用的水平扩展，但反向代理服务存在以下问题，为了解决以下问题会给系统整体增加额外的复杂度和运维成本：</p><ul><li>反向代理服务如果自身宕机，就无法访问站点，所以需要有 <strong>高可用</strong> 方案，常见的方案有：主备模式（一主一备）、双主模式（互为主备）。</li><li>反向代理服务自身也存在性能瓶颈，随着需要转发的请求量不断攀升，需要有 <strong>可扩展</strong> 方案。</li></ul></li></ul><h4 id="IP-负载均衡"><a href="#IP-负载均衡" class="headerlink" title="IP 负载均衡"></a>IP 负载均衡</h4><p>IP 负载均衡是在网络层通过修改请求目的地址进行负载均衡。</p><p><img src="https://cdn.jsdelivr.net/gh/cntotemdb/ih1@master/202106/MjwffN.png" alt="img"></p><p>如上图所示，IP 均衡处理流程大致为：</p><ol><li>客户端请求 192.168.137.10，由负载均衡服务器接收到报文。</li><li>负载均衡服务器根据算法选出一个服务节点 192.168.0.1，然后将报文请求地址改为该节点的 IP。</li><li>真实服务节点收到请求报文，处理后，返回响应数据到负载均衡服务器。</li><li>负载均衡服务器将响应数据的源地址改负载均衡服务器地址，返回给客户端。</li></ol><p>IP 负载均衡在内核进程完成数据分发，较反向代理负载均衡有更好的从处理性能。但是，由于所有请求响应都要经过负载均衡服务器，集群的吞吐量受制于负载均衡服务器的带宽。</p><h4 id="数据链路层负载均衡"><a href="#数据链路层负载均衡" class="headerlink" title="数据链路层负载均衡"></a>数据链路层负载均衡</h4><p>数据链路层负载均衡是指在通信协议的数据链路层修改 mac 地址进行负载均衡。</p><p><img src="https://cdn.jsdelivr.net/gh/cntotemdb/ih1@master/202106/RcrlZ3.png" alt="img"></p><p>在 Linux 平台上最好的链路层负载均衡开源产品是 LVS (Linux Virtual Server)。</p><p>LVS 是基于 Linux 内核中 netfilter 框架实现的负载均衡系统。netfilter 是内核态的 Linux 防火墙机制，可以在数据包流经过程中，根据规则设置若干个关卡（hook 函数）来执行相关的操作。</p><p>LVS 的工作流程大致如下：</p><ul><li>当用户访问 <a class="link" target="_blank" rel="noopener" href="http://www.sina.com.cn/">www.sina.com.cn<i class="fas fa-external-link-alt"></i></a> 时，用户数据通过层层网络，最后通过交换机进入 LVS 服务器网卡，并进入内核网络层。</li><li>进入 PREROUTING 后经过路由查找，确定访问的目的 VIP 是本机 IP 地址，所以数据包进入到 INPUT 链上</li><li>IPVS 是工作在 INPUT 链上，会根据访问的 <code>vip+port</code> 判断请求是否 IPVS 服务，如果是则调用注册的 IPVS HOOK 函数，进行 IPVS 相关主流程，强行修改数据包的相关数据，并将数据包发往 POSTROUTING 链上。</li><li>POSTROUTING 上收到数据包后，根据目标 IP 地址（后端服务器），通过路由选路，将数据包最终发往后端的服务器上。</li></ul><p>开源 LVS 版本有 3 种工作模式，每种模式工作原理截然不同，说各种模式都有自己的优缺点，分别适合不同的应用场景，不过最终本质的功能都是能实现均衡的流量调度和良好的扩展性。主要包括三种模式：DR 模式、NAT 模式、Tunnel 模式。</p><h2 id="3-负载均衡算法"><a href="#3-负载均衡算法" class="headerlink" title="3. 负载均衡算法"></a>3. 负载均衡算法</h2><p>负载均衡器的实现可以分为两个部分：</p><ul><li>根据负载均衡算法在候选服务器列表选出一个服务器；</li><li>将请求数据发送到该服务器上。</li></ul><p>负载均衡算法是负载均衡服务核心中的核心。负载均衡产品多种多样，但是各种负载均衡算法原理是共性的。</p><p>负载均衡算法有很多种，分别适用于不同的应用场景，本文仅介绍最为常见的负载均衡算法的特性及原理：轮询、随机、最小活跃数、源地址哈希、一致性哈希。</p><blockquote><p>注：负载均衡算法的实现，推荐阅读 <a class="link" target="_blank" rel="noopener" href="https://dubbo.apache.org/zh/docs/v2.7/dev/source/loadbalance/">Dubbo 官方负载均衡算法说明<i class="fas fa-external-link-alt"></i></a> ，源码讲解非常详细，非常值得借鉴。</p><p>下文中的各种算法的可执行示例已归档在 Github 仓库：<a class="link" target="_blank" rel="noopener" href="https://github.com/dunwu/java-tutorial/tree/master/codes/java-distributed/java-load-balance%EF%BC%8C%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%E6%89%A7%E8%A1%8C">https://github.com/dunwu/java-tutorial/tree/master/codes/java-distributed/java-load-balance，可以通过执行<i class="fas fa-external-link-alt"></i></a> io.github.dunwu.javatech.LoadBalanceDemo 查看各算法执行效果。</p></blockquote><h3 id="3-1-随机"><a href="#3-1-随机" class="headerlink" title="3.1. 随机"></a>3.1. 随机</h3><h4 id="随机算法"><a href="#随机算法" class="headerlink" title="随机算法"></a>随机算法</h4><p><strong><code>随机（Random）</code></strong> 算法 <strong>将请求随机分发到候选服务器</strong>。</p><p>随机算法 <strong>适合服务器硬件相同的场景</strong>。学习过概率论的都知道，调用量较小的时候，可能负载并不均匀，<strong>调用量越大，负载越均衡</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/cntotemdb/ih1@master/202106/R5FBOw.png"></p><p>【示例】随机算法实现示例</p><p>负载均衡接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LoadBalance</span>&lt;<span class="title">N</span> <span class="keyword">extends</span> <span class="title">Node</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">N <span class="title">select</span><span class="params">(List&lt;N&gt; nodes, String ip)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>负载均衡抽象类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseLoadBalance</span>&lt;<span class="title">N</span> <span class="keyword">extends</span> <span class="title">Node</span>&gt; <span class="keyword">implements</span> <span class="title">LoadBalance</span>&lt;<span class="title">N</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> N <span class="title">select</span><span class="params">(List&lt;N&gt; nodes, String ip)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtil.isEmpty(nodes)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 nodes 列表中仅有一个 node，直接返回即可，无需进行负载均衡</span></span><br><span class="line">        <span class="keyword">if</span> (nodes.size() == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nodes.get(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> doSelect(nodes, ip);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> N <span class="title">doSelect</span><span class="params">(List&lt;N&gt; nodes, String ip)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务器节点类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Node</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> String url;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Integer weight;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Integer active;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>随机算法实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomLoadBalance</span>&lt;<span class="title">N</span> <span class="keyword">extends</span> <span class="title">Node</span>&gt; <span class="keyword">extends</span> <span class="title">BaseLoadBalance</span>&lt;<span class="title">N</span>&gt; <span class="keyword">implements</span> <span class="title">LoadBalance</span>&lt;<span class="title">N</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Random random = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> N <span class="title">doSelect</span><span class="params">(List&lt;N&gt; nodes, String ip)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 在列表中随机选取一个节点</span></span><br><span class="line">        <span class="keyword">int</span> index = random.nextInt(nodes.size());</span><br><span class="line">        <span class="keyword">return</span> nodes.get(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="加权随机算法"><a href="#加权随机算法" class="headerlink" title="加权随机算法"></a>加权随机算法</h4><p><strong><code>加权随机（Weighted Random）</code></strong> 算法在随机算法的基础上，按照概率调整权重，进行负载分配。</p><p>【示例】加权随机算法实现示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeightRandomLoadBalance</span>&lt;<span class="title">N</span> <span class="keyword">extends</span> <span class="title">Node</span>&gt; <span class="keyword">extends</span> <span class="title">BaseLoadBalance</span>&lt;<span class="title">N</span>&gt; <span class="keyword">implements</span> <span class="title">LoadBalance</span>&lt;<span class="title">N</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Random random = ThreadLocalRandom.current();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> N <span class="title">doSelect</span><span class="params">(List&lt;N&gt; nodes, String ip)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> length = nodes.size();</span><br><span class="line">        AtomicInteger totalWeight = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (N node : nodes) &#123;</span><br><span class="line">            Integer weight = node.getWeight();</span><br><span class="line">            totalWeight.getAndAdd(weight);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (totalWeight.get() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> offset = random.nextInt(totalWeight.get());</span><br><span class="line">            <span class="keyword">for</span> (N node : nodes) &#123;</span><br><span class="line">                <span class="comment">// 让随机值 offset 减去权重值</span></span><br><span class="line">                offset -= node.getWeight();</span><br><span class="line">                <span class="keyword">if</span> (offset &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 返回相应的 Node</span></span><br><span class="line">                    <span class="keyword">return</span> node;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 直接随机返回一个</span></span><br><span class="line">        <span class="keyword">return</span> nodes.get(random.nextInt(length));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-轮询"><a href="#3-2-轮询" class="headerlink" title="3.2. 轮询"></a>3.2. 轮询</h3><h4 id="轮询算法"><a href="#轮询算法" class="headerlink" title="轮询算法"></a>轮询算法</h4><p><strong><code>轮询（Round Robin）</code></strong> 算法的策略是：<strong>将请求依次分发到候选服务器</strong>。</p><p>如下图所示，负载均衡器收到来自客户端的 6 个请求，(1, 3, 5) 的请求会被发送到服务器 1，(2, 4, 6) 的请求会被发送到服务器 2。</p><p><img src="https://cdn.jsdelivr.net/gh/cntotemdb/ih1@master/202106/AqZU9y.png"></p><p>该算法适合场景：各服务器处理能力相近，且每个事务工作量差异不大。如果存在较大差异，那么处理较慢的服务器就可能会积压请求，最终无法承担过大的负载。</p><p><img src="https://cdn.jsdelivr.net/gh/cntotemdb/ih1@master/202106/B2lG0i.png"></p><p>【示例】轮询算法示例</p><p>轮询负载均衡算法实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RoundRobinLoadBalance</span>&lt;<span class="title">N</span> <span class="keyword">extends</span> <span class="title">Node</span>&gt; <span class="keyword">extends</span> <span class="title">BaseLoadBalance</span>&lt;<span class="title">N</span>&gt; <span class="keyword">implements</span> <span class="title">LoadBalance</span>&lt;<span class="title">N</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger position = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> N <span class="title">doSelect</span><span class="params">(List&lt;N&gt; nodes, String ip)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = nodes.size();</span><br><span class="line">        <span class="comment">// 如果位置值已经等于节点数，重置为 0</span></span><br><span class="line">        position.compareAndSet(length, <span class="number">0</span>);</span><br><span class="line">        N node = nodes.get(position.get());</span><br><span class="line">        position.getAndIncrement();</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="加权轮询算法"><a href="#加权轮询算法" class="headerlink" title="加权轮询算法"></a>加权轮询算法</h4><p><strong><code>加权轮询（Weighted Round Robbin）</code></strong> 算法在轮询算法的基础上，增加了权重属性来调节转发服务器的请求数目。性能高、处理速度快的节点应该设置更高的权重，使得分发时优先将请求分发到权重较高的节点上。</p><p>如下图所示，服务器 A 设置权重为 5，服务器 B 设置权重为 1，负载均衡器收到来自客户端的 6 个请求，那么 (1, 2, 3, 4, 5) 请求会被发送到服务器 A，(6) 请求会被发送到服务器 B。</p><p><img src="https://cdn.jsdelivr.net/gh/cntotemdb/ih1@master/202106/xc9a1t.png"></p><p>【示例】加权轮询算法实现示例</p><p>以下实现基于 Dubbo 加权轮询算法做了一些简化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeightRoundRobinLoadBalance</span>&lt;<span class="title">N</span> <span class="keyword">extends</span> <span class="title">Node</span>&gt; <span class="keyword">extends</span> <span class="title">BaseLoadBalance</span>&lt;<span class="title">N</span>&gt; <span class="keyword">implements</span> <span class="title">LoadBalance</span>&lt;<span class="title">N</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 60秒</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RECYCLE_PERIOD = <span class="number">60000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Node hashcode 到 WeightedRoundRobin 的映射关系</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ConcurrentMap&lt;Integer, WeightedRoundRobin&gt; weightMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 原子更新锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> AtomicBoolean updateLock = <span class="keyword">new</span> AtomicBoolean();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> N <span class="title">doSelect</span><span class="params">(List&lt;N&gt; nodes, String ip)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> totalWeight = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> maxCurrent = Long.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取当前时间</span></span><br><span class="line">        <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line">        N selectedNode = <span class="keyword">null</span>;</span><br><span class="line">        WeightedRoundRobin selectedWRR = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下面这个循环主要做了这样几件事情：</span></span><br><span class="line">        <span class="comment">//   1. 遍历 Node 列表，检测当前 Node 是否有相应的 WeightedRoundRobin，没有则创建</span></span><br><span class="line">        <span class="comment">//   2. 检测 Node 权重是否发生了变化，若变化了，则更新 WeightedRoundRobin 的 weight 字段</span></span><br><span class="line">        <span class="comment">//   3. 让 current 字段加上自身权重，等价于 current += weight</span></span><br><span class="line">        <span class="comment">//   4. 设置 lastUpdate 字段，即 lastUpdate = now</span></span><br><span class="line">        <span class="comment">//   5. 寻找具有最大 current 的 Node，以及 Node 对应的 WeightedRoundRobin，</span></span><br><span class="line">        <span class="comment">//      暂存起来，留作后用</span></span><br><span class="line">        <span class="comment">//   6. 计算权重总和</span></span><br><span class="line">        <span class="keyword">for</span> (N node : nodes) &#123;</span><br><span class="line">            <span class="keyword">int</span> hashCode = node.hashCode();</span><br><span class="line">            WeightedRoundRobin weightedRoundRobin = weightMap.get(hashCode);</span><br><span class="line">            <span class="keyword">int</span> weight = node.getWeight();</span><br><span class="line">            <span class="keyword">if</span> (weight &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                weight = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检测当前 Node 是否有对应的 WeightedRoundRobin，没有则创建</span></span><br><span class="line">            <span class="keyword">if</span> (weightedRoundRobin == <span class="keyword">null</span>) &#123;</span><br><span class="line">                weightedRoundRobin = <span class="keyword">new</span> WeightedRoundRobin();</span><br><span class="line">                <span class="comment">// 设置 Node 权重</span></span><br><span class="line">                weightedRoundRobin.setWeight(weight);</span><br><span class="line">                <span class="comment">// 存储 url 唯一标识 identifyString 到 weightedRoundRobin 的映射关系</span></span><br><span class="line">                weightMap.putIfAbsent(hashCode, weightedRoundRobin);</span><br><span class="line">                weightedRoundRobin = weightMap.get(hashCode);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Node 权重不等于 WeightedRoundRobin 中保存的权重，说明权重变化了，此时进行更新</span></span><br><span class="line">            <span class="keyword">if</span> (weight != weightedRoundRobin.getWeight()) &#123;</span><br><span class="line">                weightedRoundRobin.setWeight(weight);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 让 current 加上自身权重，等价于 current += weight</span></span><br><span class="line">            <span class="keyword">long</span> current = weightedRoundRobin.increaseCurrent();</span><br><span class="line">            <span class="comment">// 设置 lastUpdate，表示近期更新过</span></span><br><span class="line">            weightedRoundRobin.setLastUpdate(now);</span><br><span class="line">            <span class="comment">// 找出最大的 current</span></span><br><span class="line">            <span class="keyword">if</span> (current &gt; maxCurrent) &#123;</span><br><span class="line">                maxCurrent = current;</span><br><span class="line">                <span class="comment">// 将具有最大 current 权重的 Node 赋值给 selectedNode</span></span><br><span class="line">                selectedNode = node;</span><br><span class="line">                <span class="comment">// 将 Node 对应的 weightedRoundRobin 赋值给 selectedWRR，留作后用</span></span><br><span class="line">                selectedWRR = weightedRoundRobin;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 计算权重总和</span></span><br><span class="line">            totalWeight += weight;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对 weightMap 进行检查，过滤掉长时间未被更新的节点。</span></span><br><span class="line">        <span class="comment">// 该节点可能挂了，nodes 中不包含该节点，所以该节点的 lastUpdate 长时间无法被更新。</span></span><br><span class="line">        <span class="comment">// 若未更新时长超过阈值后，就会被移除掉，默认阈值为60秒。</span></span><br><span class="line">        <span class="keyword">if</span> (!updateLock.get() &amp;&amp; nodes.size() != weightMap.size()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (updateLock.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 遍历修改，即移除过期记录</span></span><br><span class="line">                    weightMap.entrySet().removeIf(item -&gt; now - item.getValue().getLastUpdate() &gt; RECYCLE_PERIOD);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    updateLock.set(<span class="keyword">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (selectedNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 让 current 减去权重总和，等价于 current -= totalWeight</span></span><br><span class="line">            selectedWRR.decreaseCurrent(totalWeight);</span><br><span class="line">            <span class="comment">// 返回具有最大 current 的 Node</span></span><br><span class="line">            <span class="keyword">return</span> selectedNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// should not happen here</span></span><br><span class="line">        <span class="keyword">return</span> nodes.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WeightedRoundRobin</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 服务提供者权重</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> weight;</span><br><span class="line">        <span class="comment">// 当前权重</span></span><br><span class="line">        <span class="keyword">private</span> AtomicLong current = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 最后一次更新时间</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">long</span> lastUpdate;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">increaseCurrent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// current = current + weight；</span></span><br><span class="line">            <span class="keyword">return</span> current.addAndGet(weight);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">decreaseCurrent</span><span class="params">(<span class="keyword">int</span> total)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// current = current - total;</span></span><br><span class="line">            <span class="keyword">return</span> current.addAndGet(-<span class="number">1</span> * total);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getWeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> weight;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWeight</span><span class="params">(<span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.weight = weight;</span><br><span class="line">            <span class="comment">// 初始情况下，current = 0</span></span><br><span class="line">            current.set(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> AtomicLong <span class="title">getCurrent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> current;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCurrent</span><span class="params">(AtomicLong current)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.current = current;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getLastUpdate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> lastUpdate;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLastUpdate</span><span class="params">(<span class="keyword">long</span> lastUpdate)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.lastUpdate = lastUpdate;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-最小活跃数"><a href="#3-3-最小活跃数" class="headerlink" title="3.3. 最小活跃数"></a>3.3. 最小活跃数</h3><p><strong><code>最小活跃数（Least Active）</code></strong> 算法 <strong>将请求分发到连接数/请求数最少的候选服务器</strong>（目前处理请求最少的服务器）。</p><ul><li>特点：根据候选服务器当前的请求连接数，动态分配。</li><li>场景：<strong>适用于对系统负载较为敏感或请求连接时长相差较大的场景</strong>。</li></ul><p>由于每个请求的连接时长不一样，如果采用简单的轮循或随机算法，都可能出现<strong>某些服务器当前连接数过大，而另一些服务器的连接过小</strong>的情况，这就造成了负载并非真正均衡。虽然，轮询或算法都可以通过加权重属性的方式进行负载调整，但加权方式难以应对动态变化。</p><p><img src="https://cdn.jsdelivr.net/gh/cntotemdb/ih1@master/202106/yHU3n6.png"></p><p>最小活跃数算法会记录当前时刻，每个候选节点正在处理的连接数，然后选择连接数最小的节点。该策略能够动态、实时地反应服务器的当前状况，较为合理地将负责分配均匀，适用于对当前系统负载较为敏感的场景。</p><p>例如下图中，服务器 1 当前连接数最小，那么新到来的请求 6 就会被发送到服务器 1 上。</p><p><img src="https://cdn.jsdelivr.net/gh/cntotemdb/ih1@master/202106/GRqvvm.png"></p><p><strong>加权最小活跃数（Weighted Least Connection）</strong>在最小活跃数的基础上，根据服务器的性能为每台服务器分配权重，再根据权重计算出每台服务器能处理的连接数。</p><p>最小活跃数算法实现要点：活跃调用数越小，表明该服务节点处理能力越高，单位时间内可处理更多的请求，应优先将请求分发给该服务。在具体实现中，每个服务节点对应一个活跃数 active。初始情况下，所有服务提供者活跃数均为 0。每收到一个请求，活跃数加 1，完成请求后则将活跃数减 1。在服务运行一段时间后，性能好的服务提供者处理请求的速度更快，因此活跃数下降的也越快，此时这样的服务提供者能够优先获取到新的服务请求、这就是最小活跃数负载均衡算法的基本思想。</p><p>【示例】最小活跃数算法实现</p><p>以下实现基于 Dubbo 最小活跃数负载均衡算法做了些许改动。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeastActiveLoadBalance</span>&lt;<span class="title">N</span> <span class="keyword">extends</span> <span class="title">Node</span>&gt; <span class="keyword">extends</span> <span class="title">BaseLoadBalance</span>&lt;<span class="title">N</span>&gt; <span class="keyword">implements</span> <span class="title">LoadBalance</span>&lt;<span class="title">N</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Random random = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> N <span class="title">doSelect</span><span class="params">(List&lt;N&gt; nodes, String ip)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = nodes.size();</span><br><span class="line">        <span class="comment">// 最小的活跃数</span></span><br><span class="line">        <span class="keyword">int</span> leastActive = -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 具有相同“最小活跃数”的服务者提供者（以下用 Node 代称）数量</span></span><br><span class="line">        <span class="keyword">int</span> leastCount = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// leastIndexs 用于记录具有相同“最小活跃数”的 Node 在 nodes 列表中的下标信息</span></span><br><span class="line">        <span class="keyword">int</span>[] leastIndexs = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        <span class="keyword">int</span> totalWeight = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 第一个最小活跃数的 Node 权重值，用于与其他具有相同最小活跃数的 Node 的权重进行对比，</span></span><br><span class="line">        <span class="comment">// 以检测是否“所有具有相同最小活跃数的 Node 的权重”均相等</span></span><br><span class="line">        <span class="keyword">int</span> firstWeight = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span> sameWeight = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历 nodes 列表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            N node = nodes.get(i);</span><br><span class="line">            <span class="comment">// 发现更小的活跃数，重新开始</span></span><br><span class="line">            <span class="keyword">if</span> (leastActive == -<span class="number">1</span> || node.getActive() &lt; leastActive) &#123;</span><br><span class="line">                <span class="comment">// 使用当前活跃数更新最小活跃数 leastActive</span></span><br><span class="line">                leastActive = node.getActive();</span><br><span class="line">                <span class="comment">// 更新 leastCount 为 1</span></span><br><span class="line">                leastCount = <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 记录当前下标值到 leastIndexs 中</span></span><br><span class="line">                leastIndexs[<span class="number">0</span>] = i;</span><br><span class="line">                totalWeight = node.getWeight();</span><br><span class="line">                firstWeight = node.getWeight();</span><br><span class="line">                sameWeight = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 当前 Node 的活跃数 node.getActive() 与最小活跃数 leastActive 相同</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.getActive() == leastActive) &#123;</span><br><span class="line">                <span class="comment">// 在 leastIndexs 中记录下当前 Node 在 nodes 集合中的下标</span></span><br><span class="line">                leastIndexs[leastCount++] = i;</span><br><span class="line">                <span class="comment">// 累加权重</span></span><br><span class="line">                totalWeight += node.getWeight();</span><br><span class="line">                <span class="comment">// 检测当前 Node 的权重与 firstWeight 是否相等，</span></span><br><span class="line">                <span class="comment">// 不相等则将 sameWeight 置为 false</span></span><br><span class="line">                <span class="keyword">if</span> (sameWeight &amp;&amp; i &gt; <span class="number">0</span></span><br><span class="line">                    &amp;&amp; node.getWeight() != firstWeight) &#123;</span><br><span class="line">                    sameWeight = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当只有一个 Node 具有最小活跃数，此时直接返回该 Node 即可</span></span><br><span class="line">        <span class="keyword">if</span> (leastCount == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nodes.get(leastIndexs[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 有多个 Node 具有相同的最小活跃数，但它们之间的权重不同</span></span><br><span class="line">        <span class="keyword">if</span> (!sameWeight &amp;&amp; totalWeight &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 随机生成一个 [0, totalWeight) 之间的数字</span></span><br><span class="line">            <span class="keyword">int</span> offsetWeight = random.nextInt(totalWeight);</span><br><span class="line">            <span class="comment">// 循环让随机数减去具有最小活跃数的 Node 的权重值，</span></span><br><span class="line">            <span class="comment">// 当 offset 小于等于0时，返回相应的 Node</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; leastCount; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> leastIndex = leastIndexs[i];</span><br><span class="line">                <span class="comment">// 获取权重值，并让随机数减去权重值</span></span><br><span class="line">                offsetWeight -= nodes.get(leastIndex).getWeight();</span><br><span class="line">                <span class="keyword">if</span> (offsetWeight &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> nodes.get(leastIndex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果权重相同或权重为0时，随机返回一个 Node</span></span><br><span class="line">        <span class="keyword">return</span> nodes.get(leastIndexs[random.nextInt(leastCount)]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-哈希"><a href="#3-4-哈希" class="headerlink" title="3.4. 哈希"></a>3.4. 哈希</h3><p>**<code>哈希（IP Hash）</code>**算法 <strong>根据一个 key （可以是唯一ID、IP 等），通过哈希计算得到一个数值，用该数值在候选服务器列表的进行取模运算，得到的结果便是选中的服务器</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/cntotemdb/ih1@master/202106/HsKQF6.png"></p><p>可以保证同一 IP 的客户端的请求会转发到同一台服务器上，用来实现会话粘滞（Sticky Session）。</p><ul><li>特点：保证特定用户总是请求到相同的服务器，若服务器宕机，会话会丢失。</li></ul><p>【示例】源地址哈希算法实现示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IpHashLoadBalance</span>&lt;<span class="title">N</span> <span class="keyword">extends</span> <span class="title">Node</span>&gt; <span class="keyword">extends</span> <span class="title">BaseLoadBalance</span>&lt;<span class="title">N</span>&gt; <span class="keyword">implements</span> <span class="title">LoadBalance</span>&lt;<span class="title">N</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> N <span class="title">doSelect</span><span class="params">(List&lt;N&gt; nodes, String ip)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isBlank(ip)) &#123;</span><br><span class="line">            ip = <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> length = nodes.size();</span><br><span class="line">        <span class="keyword">int</span> index = hash(ip) % length;</span><br><span class="line">        <span class="keyword">return</span> nodes.get(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(String text)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> HashUtil.fnvHash(text);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-5-一致性哈希"><a href="#3-5-一致性哈希" class="headerlink" title="3.5. 一致性哈希"></a>3.5. 一致性哈希</h3><p>一致性哈希（Consistent Hash）算法的目标是：<strong>相同的请求尽可能落到同一个服务器上</strong>。</p><p><strong>一致性哈希</strong> 可以很好的解决 <strong>稳定性问题</strong>，可以将所有的 <strong>存储节点</strong> 排列在 <strong>首尾相接</strong> 的 <code>Hash</code> 环上，每个 <code>key</code> 在计算 <code>Hash</code> 后会 <strong>顺时针</strong> 找到 <strong>临接</strong> 的 <strong>存储节点</strong> 存放。而当有节点 <strong>加入</strong> 或 <strong>退出</strong> 时，仅影响该节点在 <code>Hash</code> 环上 <strong>顺时针相邻</strong> 的 <strong>后续节点</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/cntotemdb/ih1@master/202106/31PKxt.png" alt="img"></p><ul><li>相同的请求是指：一般在使用一致性哈希时，需要指定一个 key 用于 hash 计算，可能是：<ul><li>用户 ID</li><li>请求方 IP</li><li>请求服务名称，参数列表构成的串</li></ul></li><li>尽可能是指：服务器可能发生上下线，少数服务器的变化不应该影响大多数的请求。</li></ul><p>当某台候选服务器宕机时，原本发往该服务器的请求，会基于虚拟节点，平摊到其它候选服务器，不会引起剧烈变动。</p><ul><li><strong>优点</strong></li></ul><p><strong>加入</strong> 和 <strong>删除</strong> 节点只影响 <strong>哈希环</strong> 中 <strong>顺时针方向</strong> 的 <strong>相邻的节点</strong>，对其他节点无影响。</p><ul><li><strong>缺点</strong></li></ul><p><strong>加减节点</strong> 会造成 <strong>哈希环</strong> 中部分数据 <strong>无法命中</strong>。当使用 <strong>少量节点</strong> 时，<strong>节点变化</strong> 将大范围影响 <strong>哈希环</strong> 中 <strong>数据映射</strong>，不适合 <strong>少量数据节点</strong> 的分布式方案。<strong>普通</strong> 的 <strong>一致性哈希分区</strong> 在增减节点时需要 <strong>增加一倍</strong> 或 <strong>减去一半</strong> 节点才能保证 <strong>数据</strong> 和 <strong>负载的均衡</strong>。</p><blockquote><p><strong>注意</strong>：因为 <strong>一致性哈希分区</strong> 的这些缺点，一些分布式系统采用 <strong>虚拟槽</strong> 对 <strong>一致性哈希</strong> 进行改进，比如 <code>Dynamo</code> 系统。</p></blockquote><p>【示例】一致性哈希算法示例</p><p>以下示例基于 Dubbo 的一致性哈希负载均衡算法做了一些简化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsistentHashLoadBalance</span>&lt;<span class="title">N</span> <span class="keyword">extends</span> <span class="title">Node</span>&gt; <span class="keyword">extends</span> <span class="title">BaseLoadBalance</span>&lt;<span class="title">N</span>&gt; <span class="keyword">implements</span> <span class="title">LoadBalance</span>&lt;<span class="title">N</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;String, ConsistentHashSelector&lt;?&gt;&gt; selectors = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> N <span class="title">doSelect</span><span class="params">(List&lt;N&gt; nodes, String ip)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 分片数，这里设为节点数的 4 倍</span></span><br><span class="line">        Integer replicaNum = nodes.size() * <span class="number">4</span>;</span><br><span class="line">        <span class="comment">// 获取 nodes 原始的 hashcode</span></span><br><span class="line">        <span class="keyword">int</span> identityHashCode = System.identityHashCode(nodes);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 nodes 是一个新的 List 对象，意味着节点数量发生了变化</span></span><br><span class="line">        <span class="comment">// 此时 selector.identityHashCode != identityHashCode 条件成立</span></span><br><span class="line">        ConsistentHashSelector&lt;N&gt; selector = (ConsistentHashSelector&lt;N&gt;) selectors.get(ip);</span><br><span class="line">        <span class="keyword">if</span> (selector == <span class="keyword">null</span> || selector.identityHashCode != identityHashCode) &#123;</span><br><span class="line">            <span class="comment">// 创建新的 ConsistentHashSelector</span></span><br><span class="line">            selectors.put(ip, <span class="keyword">new</span> ConsistentHashSelector&lt;&gt;(nodes, identityHashCode, replicaNum));</span><br><span class="line">            selector = (ConsistentHashSelector&lt;N&gt;) selectors.get(ip);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 调用 ConsistentHashSelector 的 select 方法选择 Node</span></span><br><span class="line">        <span class="keyword">return</span> selector.select(ip);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 一致性哈希选择器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsistentHashSelector</span>&lt;<span class="title">N</span> <span class="keyword">extends</span> <span class="title">Node</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 存储虚拟节点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> TreeMap&lt;Long, N&gt; virtualNodes;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> identityHashCode;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 构造器</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> nodes            节点列表</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> identityHashCode hashcode</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> replicaNum       分片数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ConsistentHashSelector(List&lt;N&gt; nodes, <span class="keyword">int</span> identityHashCode, Integer replicaNum) &#123;</span><br><span class="line">            <span class="keyword">this</span>.virtualNodes = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">            <span class="keyword">this</span>.identityHashCode = identityHashCode;</span><br><span class="line">            <span class="comment">// 获取虚拟节点数，默认为 100</span></span><br><span class="line">            <span class="keyword">if</span> (replicaNum == <span class="keyword">null</span>) &#123;</span><br><span class="line">                replicaNum = <span class="number">100</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (N node : nodes) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; replicaNum / <span class="number">4</span>; i++) &#123;</span><br><span class="line">                    <span class="comment">// 对 url 进行 md5 运算，得到一个长度为16的字节数组</span></span><br><span class="line">                    <span class="keyword">byte</span>[] digest = md5(node.getUrl());</span><br><span class="line">                    <span class="comment">// 对 digest 部分字节进行 4 次 hash 运算，得到四个不同的 long 型正整数</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">                        <span class="comment">// h = 0 时，取 digest 中下标为 0 ~ 3 的4个字节进行位运算</span></span><br><span class="line">                        <span class="comment">// h = 1 时，取 digest 中下标为 4 ~ 7 的4个字节进行位运算</span></span><br><span class="line">                        <span class="comment">// h = 2, h = 3 时过程同上</span></span><br><span class="line">                        <span class="keyword">long</span> m = hash(digest, j);</span><br><span class="line">                        <span class="comment">// 将 hash 到 node 的映射关系存储到 virtualNodes 中，</span></span><br><span class="line">                        <span class="comment">// virtualNodes 需要提供高效的查询操作，因此选用 TreeMap 作为存储结构</span></span><br><span class="line">                        virtualNodes.put(m, node);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> N <span class="title">select</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 对参数 key 进行 md5 运算</span></span><br><span class="line">            <span class="keyword">byte</span>[] digest = md5(key);</span><br><span class="line">            <span class="comment">// 取 digest 数组的前四个字节进行 hash 运算，再将 hash 值传给 selectForKey 方法，</span></span><br><span class="line">            <span class="comment">// 寻找合适的 Node</span></span><br><span class="line">            <span class="keyword">return</span> selectForKey(hash(digest, <span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> N <span class="title">selectForKey</span><span class="params">(<span class="keyword">long</span> hash)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 查找第一个大于或等于当前 hash 的节点</span></span><br><span class="line">            Map.Entry&lt;Long, N&gt; entry = virtualNodes.ceilingEntry(hash);</span><br><span class="line">            <span class="comment">// 如果 hash 大于 Node 在哈希环上最大的位置，此时 entry = null，</span></span><br><span class="line">            <span class="comment">// 需要将 TreeMap 的头节点赋值给 entry</span></span><br><span class="line">            <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</span><br><span class="line">                entry = virtualNodes.firstEntry();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 返回 Node</span></span><br><span class="line">            <span class="keyword">return</span> entry.getValue();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算 hash 值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">hash</span><span class="params">(<span class="keyword">byte</span>[] digest, <span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (((<span class="keyword">long</span>) (digest[<span class="number">3</span> + number * <span class="number">4</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">24</span>)</span><br><span class="line">            | ((<span class="keyword">long</span>) (digest[<span class="number">2</span> + number * <span class="number">4</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">16</span>)</span><br><span class="line">            | ((<span class="keyword">long</span>) (digest[<span class="number">1</span> + number * <span class="number">4</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">8</span>)</span><br><span class="line">            | (digest[number * <span class="number">4</span>] &amp; <span class="number">0xFF</span>))</span><br><span class="line">            &amp; <span class="number">0xFFFFFFFFL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算 MD5 值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] md5(String value) &#123;</span><br><span class="line">        MessageDigest md5;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            md5 = MessageDigest.getInstance(<span class="string">&quot;MD5&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">        md5.reset();</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = value.getBytes(StandardCharsets.UTF_8);</span><br><span class="line">        md5.update(bytes);</span><br><span class="line">        <span class="keyword">return</span> md5.digest();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-参考资料"><a href="#4-参考资料" class="headerlink" title="4. 参考资料"></a>4. 参考资料</h2><ul><li><a class="link" target="_blank" rel="noopener" href="https://www.youtube.com/watch?reload=9&app=desktop&v=iqOTT7_7qXY">Comparing Load Balancing Algorithms<i class="fas fa-external-link-alt"></i></a></li><li><a class="link" target="_blank" rel="noopener" href="https://item.jd.com/11322972.html">《大型网站技术架构：核心原理与案例分析》<i class="fas fa-external-link-alt"></i></a></li><li><a class="link" target="_blank" rel="noopener" href="https://www.cnblogs.com/itfly8/p/5043435.html">大型网站架构系列：负载均衡详解（1）<i class="fas fa-external-link-alt"></i></a></li><li><a class="link" target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/32841479">什么是负载均衡<i class="fas fa-external-link-alt"></i></a></li><li><a class="link" target="_blank" rel="noopener" href="https://avinetworks.com/what-is-load-balancing/">What Is Load Balancing<i class="fas fa-external-link-alt"></i></a></li><li><a class="link" target="_blank" rel="noopener" href="https://dubbo.apache.org/zh/docs/v2.7/dev/source/loadbalance/">Dubbo 官方负载均衡算法说明<i class="fas fa-external-link-alt"></i></a></li><li><a class="link" target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000004492447">负载均衡算法及手段<i class="fas fa-external-link-alt"></i></a></li><li><a class="link" target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000002578457">利用 dns 解析来实现网站的负载均衡<i class="fas fa-external-link-alt"></i></a></li></ul></div><div class="article-nav"><div class="article-prev"><a class="prev" rel="prev" href="../eb4f7124714d/"><span class="left arrow-icon flex-center"><i class="fas fa-chevron-left"></i> </span><span class="title flex-center"><span class="post-nav-title-item">系统原理面试题</span> <span class="post-nav-item">上一篇</span></span></a></div><div class="article-next"><a class="next" rel="next" href="../6c9411ac3e29/"><span class="title flex-center"><span class="post-nav-title-item">秒杀系统设计</span> <span class="post-nav-item">下一篇</span> </span><span class="right arrow-icon flex-center"><i class="fas fa-chevron-right"></i></span></a></div></div></div></div></div></div><div class="page-main-content-bottom"><footer class="footer"><div class="info-container"><div class="copyright-info info-item">&copy; <span>2021</span>&nbsp;-&nbsp; 2021&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">九天图腾</a></div><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="website-count info-item"><span id="busuanzi_container_site_uv">访问人数&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp; </span><span id="busuanzi_container_site_pv">总访问量&nbsp;<span id="busuanzi_value_site_pv"></span></span></div><div class="theme-info info-item">由 <a target="_blank" href="https://hexo.io">Hexo</a> 驱动&nbsp;|&nbsp;主题&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.3</a></div></div></footer></div></div><div class="post-tools"><div class="post-tools-container"><ul class="tools-list"><li class="tools-item page-aside-toggle"><i class="fas fa-outdent"></i></li></ul></div></div><div class="right-bottom-side-tools"><div class="side-tools-container"><ul class="side-tools-list"><li class="tools-item tool-font-adjust-plus flex-center"><i class="fas fa-search-plus"></i></li><li class="tools-item tool-font-adjust-minus flex-center"><i class="fas fa-search-minus"></i></li><li class="tools-item tool-expand-width flex-center"><i class="fas fa-arrows-alt-h"></i></li><li class="tools-item tool-dark-light-toggle flex-center"><i class="fas fa-moon"></i></li><li class="tools-item tool-scroll-to-bottom flex-center"><i class="fas fa-arrow-down"></i></li></ul><ul class="exposed-tools-list"><li class="tools-item tool-toggle-show flex-center"><i class="fas fa-cog fa-spin"></i></li><li class="tools-item tool-scroll-to-top flex-center"><i class="arrow-up fas fa-arrow-up"></i> <span class="percent"></span></li></ul></div></div><aside class="page-aside"><div class="post-toc-wrap"><div class="post-toc"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="nav-text">深入浅出负载均衡</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%80%E4%BB%8B"><span class="nav-text">1. 负载均衡简介</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E9%9D%A2%E4%B8%B4%E7%9A%84%E6%8C%91%E6%88%98"><span class="nav-text">1.1. 大型网站面临的挑战</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E4%BB%80%E4%B9%88%E6%98%AF%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="nav-text">1.2. 什么是负载均衡</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-text">2. 负载均衡的分类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E8%BD%BD%E4%BD%93%E7%BB%B4%E5%BA%A6%E5%88%86%E7%B1%BB"><span class="nav-text">2.1. 载体维度分类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A1%AC%E4%BB%B6%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="nav-text">硬件负载均衡</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BD%AF%E4%BB%B6%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="nav-text">软件负载均衡</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%88%86%E7%B1%BB"><span class="nav-text">2.2. 网络通信分类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#DNS-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="nav-text">DNS 负载均衡</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTP-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="nav-text">HTTP 负载均衡</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="nav-text">反向代理负载均衡</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#IP-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="nav-text">IP 负载均衡</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="nav-text">数据链路层负载均衡</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95"><span class="nav-text">3. 负载均衡算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E9%9A%8F%E6%9C%BA"><span class="nav-text">3.1. 随机</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9A%8F%E6%9C%BA%E7%AE%97%E6%B3%95"><span class="nav-text">随机算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A0%E6%9D%83%E9%9A%8F%E6%9C%BA%E7%AE%97%E6%B3%95"><span class="nav-text">加权随机算法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E8%BD%AE%E8%AF%A2"><span class="nav-text">3.2. 轮询</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BD%AE%E8%AF%A2%E7%AE%97%E6%B3%95"><span class="nav-text">轮询算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A0%E6%9D%83%E8%BD%AE%E8%AF%A2%E7%AE%97%E6%B3%95"><span class="nav-text">加权轮询算法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-%E6%9C%80%E5%B0%8F%E6%B4%BB%E8%B7%83%E6%95%B0"><span class="nav-text">3.3. 最小活跃数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-%E5%93%88%E5%B8%8C"><span class="nav-text">3.4. 哈希</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C"><span class="nav-text">3.5. 一致性哈希</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="nav-text">4. 参考资料</span></a></li></ol></li></ol></div></div></aside><div class="image-viewer-container"><img src=""></div><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-input-field-pre"><i class="fas fa-keyboard"></i></span><div class="search-input-container"><input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fas fa-times"></i></span></div><div id="search-result"><div id="no-result"><i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></main><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/utils.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/main.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/header-shrink.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/back2top.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/dark-light-toggle.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/local-search.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/code-copy.js"></script><div class="post-scripts"><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/left-side-toggle.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/libs/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/toc.js"></script></div></body></html>